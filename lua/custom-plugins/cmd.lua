local ok, uv = pcall(function()
  return vim.uv or vim.loop
end)
if not ok or uv == nil then
  error("Cmd.nvim: libuv not available")
end

local nvim = vim.version()
if nvim.major == 0 and nvim.minor < 10 then
  error("Cmd.nvim requires Neovim 0.10+")
end

---@class Cmd
local Cmd = {}

---@class Cmd.Helpers
local H = {}

---@class Cmd.UI
local U = {
  spinner_adapters = {},
}

---@class Cmd.Core
local C = {}

------------------------------------------------------------------
-- Constants & Setup
------------------------------------------------------------------

---@class Cmd.CommandHistory
---@field id integer
---@field cmd? string[]
---@field timestamp? number
---@field type? "normal"|"interactive"
---@field status? Cmd.CommandStatus
---@field job? uv.uv_process_t|nil

---@alias Cmd.CommandStatus "success"|"failed"|"cancelled"|"running"

---@class Cmd.Spinner
---@field timer uv.uv_timer_t|nil
---@field active boolean
---@field msg string
---@field title string
---@field cmd string

---@class Cmd.State
---@field cwd string
---@field temp_script_cache table<string, string>
---@field spinner_state table<integer, Cmd.Spinner>
---@field command_history Cmd.CommandHistory[]
local S = {
  cwd = "",
  temp_script_cache = {},
  spinner_state = {},
  command_history = {},
}

---@type table<Cmd.CommandStatus, string>
local icon_map = {
  success = " ",
  failed = " ",
  cancelled = " ",
}

---@type table<Cmd.CommandStatus, string>
local level_map = {
  success = "INFO",
  failed = "ERROR",
  cancelled = "WARN",
}

---@type table<Cmd.CommandStatus, string>
local hl_groups = {
  success = "CmdSuccess",
  failed = "CmdFailed",
  cancelled = "CmdCancelled",
}

------------------------------------------------------------------
-- Helpers
------------------------------------------------------------------

---Safely delete a file.
function H.safe_delete(path)
  vim.defer_fn(function()
    pcall(vim.fn.delete, path)
  end, 0)
end

---Ensure that the current working directory is set.
function H.ensure_cwd()
  local buf_dir = vim.fn.expand("%:p:h")

  if buf_dir and vim.fn.isdirectory(buf_dir) == 1 then
    S.cwd = buf_dir
  else
    S.cwd = vim.fn.getcwd()
  end
end

---@alias Cmd.LogLevel "INFO"|"WARN"|"ERROR"

---Display a notification.
---@param msg string
---@param lvl Cmd.LogLevel
---@param opts? table
---@return nil
function H.notify(msg, lvl, opts)
  opts = opts or {}
  opts.title = opts.title or "cmd"
  vim.notify(msg, vim.log.levels[lvl:upper()], opts)
end

---Stream chunks to a string.
---@param chunks string[]
---@return string
function H.stream_tostring(chunks)
  return (table.concat(chunks):gsub("\r", "\n"))
end

---Start reading a stream into a buffer.
---@param pipe uv.uv_stream_t
---@param buffer string[]
---@return nil
function H.read_stream(pipe, buffer)
  uv.read_start(pipe, function(err, chunk)
    if err then
      return
    end
    if chunk then
      buffer[#buffer + 1] = chunk
    end
  end)
end

---Trim empty lines from a string array.
---@param lines string[]
---@return string[]
function H.trim_empty_lines(lines)
  return vim.tbl_filter(function(s)
    return s ~= ""
  end, lines)
end

---Get the environment variables for a command.
---@param executable string
---@return string[]|nil
function H.get_cmd_env(executable)
  local env = Cmd.config.env or {}

  ---@type string[]
  local found = {}

  if not vim.tbl_isempty(env) then
    for k, v in pairs(env) do
      if k == executable then
        for _, v2 in ipairs(v) do
          table.insert(found, v2)
        end
      end
    end
  end

  if #found == 0 then
    return nil
  end

  return found
end

---Sanitize a line.
---@param line string
---@return string
function H.sanitize_line(line)
  line = line
    :gsub("\27%[[%d:;]*%d?[ -/]*[@-~]", "") -- Strip every CSI escape. NOTE: Generated by AI
    :gsub("^%s+", "") -- trim leading whitespaces
    :gsub("%s+$", "") -- trim trailing whitespaces
  if Cmd.config.completion.prompt_pattern_to_remove then
    --- trim the whitespaces again after removing the prompt pattern
    line = line:gsub(Cmd.config.completion.prompt_pattern_to_remove, ""):gsub("^%s+", ""):gsub("%s+$", "")
  end
  return line
end

---Sanitize the output of a file handle.
---@param lines string[]
---@return string[]
function H.sanitize_file_output(lines)
  ---@type string[]
  local cleaned = {}
  for _, l in ipairs(lines) do
    local first = (H.sanitize_line(l):gsub("\t.*", "")) -- NOTE: safer split
    if first ~= "" then
      table.insert(cleaned, first)
    end
  end

  return cleaned
end

---Write a temporary shell script.
---@param shell string
---@return string|nil
function H.write_temp_script(shell)
  if S.temp_script_cache[shell] then
    return S.temp_script_cache[shell]
  end

  local path = vim.fn.tempname() .. ".sh"
  local content = ""

  if shell:find("fish") then
    content = [[
#!/usr/bin/env fish
set -l input "$argv"
complete -C "$input"
]]
  elseif shell:find("zsh") then
    content = [[
#!/usr/bin/env zsh
autoload -U +X compinit && compinit -u
autoload -U +X bashcompinit && bashcompinit -u
setopt no_aliases
local line=$1
BUFFER=$line
CURSOR=${#line}
zle -C my-complete complete-word _main_complete
zle my-complete
]]
  else -- bash
    content = [[
#!/usr/bin/env bash
COMP_LINE=$1
COMP_POINT=${#1}
IFS=' ' read -ra COMP_WORDS <<< "$COMP_LINE"
COMP_CWORD=$((${#COMP_WORDS[@]}-1))
cmd="${COMP_WORDS[0]}"
type _completion_loader &>/dev/null && _completion_loader "$cmd"
type "_$cmd" &>/dev/null && "_$cmd"
printf '%s\n' "${COMPREPLY[@]}"
]]
  end

  local fd = uv.fs_open(path, "w", 384) -- 0600
  if not fd then
    return nil
  end
  uv.fs_write(fd, content)
  uv.fs_close(fd)

  S.temp_script_cache[shell] = path

  return path
end

function H.prepare_history()
  -- Pull out non-nil entries
  local list = {}
  for _, v in pairs(S.command_history) do
    table.insert(list, v)
  end
  table.sort(list, function(a, b)
    return a.id < b.id
  end)

  -- Rebuild sparse array with contiguous ids starting at 1
  S.command_history = {}
  for i, v in ipairs(list) do
    v.id = i
    S.command_history[i] = v
  end
end

---@param command_id integer
---@param opts Cmd.Spinner|nil
function H.set_spinner_state(command_id, opts)
  if opts and not vim.tbl_isempty(opts) then
    opts = vim.tbl_deep_extend("force", S.spinner_state[command_id] or {}, opts)
  end

  S.spinner_state[command_id] = opts
end

---@param command_id integer
---@return Cmd.Spinner|nil
function H.get_spinner_state(command_id)
  return S.spinner_state[command_id]
end

------------------------------------------------------------------
-- UI
------------------------------------------------------------------

---@class Cmd.SpinnerDriver
---@field pre_exec fun(opts: Cmd.Config.AsyncNotifier.PreExec): string|integer|number|nil
---@field post_exec fun(opts: Cmd.Config.AsyncNotifier.PostExec)

---@param adapter Cmd.Config.AsyncNotifier.SpinnerAdapter
---@return Cmd.SpinnerDriver
function U.spinner_driver(adapter)
  return {
    ---@param opts Cmd.Config.AsyncNotifier.PreExec
    pre_exec = function(opts)
      local timer = uv.new_timer()
      if timer then
        opts.set_spinner_state(opts.command_id, {
          timer = timer,
          active = true,
          msg = string.format("[#%s] running `%s`", opts.command_id, opts.args),
          title = "cmd",
          cmd = opts.args,
        })
      end

      local idx = 1
      local spinner_chars = opts.spinner_chars

      local notify_id = adapter.start(string.format("[#%s] running `%s`", opts.command_id, opts.args), opts)

      if timer then
        timer:start(0, 150, function()
          vim.schedule(function()
            local st = opts.get_spinner_state(opts.command_id)
            if not st or not st.active then
              return
            end

            local msg = st.msg
            if spinner_chars and #spinner_chars > 0 then
              idx = (idx % #spinner_chars) + 1
              msg = string.format("%s %s", spinner_chars[idx], msg)
              opts.current_spinner_char = spinner_chars[idx]
            end
            adapter.update(notify_id, msg, opts)
          end)
        end)
      end
      return notify_id
    end,

    ----------------------------------------------------------------
    -- post-exec: stop spinner and show final message
    ----------------------------------------------------------------

    ---@param opts Cmd.Config.AsyncNotifier.PostExec
    post_exec = function(opts)
      local st = opts.get_spinner_state(opts.command_id)
      if not st or not st.active then
        return
      end

      if st.timer and not st.timer:is_closing() then
        st.timer:stop()
        st.timer:close()
      end
      opts.set_spinner_state(opts.command_id, nil)

      local icon = icon_map[opts.status] or " "
      local level = level_map[opts.status] or vim.log.levels.ERROR
      local msg = string.format("%s [#%s] %s `%s`", icon, opts.command_id, opts.status, st.cmd)

      ---@diagnostic disable-next-line: param-type-mismatch
      adapter.finish(opts.user_defined_notifier_id, msg, level, opts)
    end,
  }
end

---@type Cmd.Config.AsyncNotifier.SpinnerAdapter
U.spinner_adapters.snacks = {
  start = function(msg, data)
    H.notify(msg, "INFO", { id = string.format("cmd_progress_%s", data.command_id), title = "cmd" })
    return nil -- snacks uses the id internally
  end,

  update = function(_, msg, data)
    H.notify(msg, "INFO", { id = string.format("cmd_progress_%s", data.command_id), title = "cmd" })
  end,

  finish = function(_, msg, level, data)
    H.notify(msg, level, { id = string.format("cmd_progress_%s", data.command_id), title = "cmd" })
  end,
}

---@type Cmd.Config.AsyncNotifier.SpinnerAdapter
U.spinner_adapters.mini = {
  start = function(msg)
    ---@diagnostic disable-next-line: redefined-local
    local ok, mini_notify = pcall(require, "mini.notify")
    return ok and mini_notify.add(msg, "INFO", nil, {}) or nil
  end,

  update = function(id, msg)
    id = tonumber(id)
    if not id then
      return
    end
    ---@diagnostic disable-next-line: redefined-local
    local ok, mini_notify = pcall(require, "mini.notify")
    if ok then
      local data = mini_notify.get(id)
      data.msg = msg
      mini_notify.update(id, data)
    end
  end,

  finish = function(id, msg, level)
    id = tonumber(id)
    if not id then
      return
    end
    ---@diagnostic disable-next-line: redefined-local
    local ok, mini_notify = pcall(require, "mini.notify")
    if ok then
      local data = mini_notify.get(id)
      data.msg = msg
      data.level = level
      mini_notify.update(id, data)

      vim.defer_fn(function()
        mini_notify.remove(id)
      end, mini_notify.config.lsp_progress.duration_last)
    end
  end,
}

---@type Cmd.Config.AsyncNotifier.SpinnerAdapter
U.spinner_adapters.fidget = {
  start = function(msg, data)
    ---@diagnostic disable-next-line: redefined-local
    local ok, fidget = pcall(require, "fidget")
    return ok
        and fidget.notification.notify(msg, "INFO", {
          key = string.format("cmd_progress_%s", data.command_id),
          annote = "cmd",
          ttl = Cmd.config.timeout,
        })
      or nil
  end,

  update = function(_, msg, data)
    ---@diagnostic disable-next-line: redefined-local
    local ok, fidget = pcall(require, "fidget")
    if ok then
      fidget.notification.notify(msg, "INFO", {
        key = string.format("cmd_progress_%s", data.command_id),
        annote = "cmd",
        update_only = true,
      })
    end
  end,

  finish = function(_, msg, level, data)
    ---@diagnostic disable-next-line: redefined-local
    local ok, fidget = pcall(require, "fidget")
    if ok then
      fidget.notification.notify(msg, level, {
        key = string.format("cmd_progress_%s", data.command_id),
        annote = "cmd",
        update_only = true,
        ttl = 0,
      })
    end
  end,
}

---Show output in a scratch buffer (readonly, vsplit).
---@param lines string[]
---@param title string
---@param post_hook? fun(buf: integer, lines: string[])
function U.show_buffer(lines, title, post_hook)
  local old_buf = vim.fn.bufnr(title)
  if old_buf ~= -1 then
    vim.api.nvim_buf_delete(old_buf, { force = true })
  end

  vim.schedule(function()
    local buf = vim.api.nvim_create_buf(false, true)
    vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)
    vim.bo[buf].filetype = "cmd"
    vim.bo[buf].buftype = "nofile"
    vim.bo[buf].bufhidden = "wipe"
    vim.bo[buf].swapfile = false
    vim.bo[buf].modifiable = false
    vim.bo[buf].readonly = true
    vim.bo[buf].buflisted = false
    vim.api.nvim_buf_set_name(buf, title)
    vim.cmd("vsplit | buffer " .. buf)

    if post_hook then
      post_hook(buf, lines)
    end
  end)
end

---Show output in a terminal buffer.
---@param cmd string[]
---@param title string
---@param command_id integer
function U.show_terminal(cmd, title, command_id)
  C.track_cmd({
    id = command_id,
    cmd = cmd,
    type = "interactive",
    status = "running",
  })

  local buf = vim.api.nvim_create_buf(false, true)
  vim.bo[buf].filetype = "cmd"
  vim.bo[buf].bufhidden = "wipe"
  vim.bo[buf].swapfile = false
  vim.bo[buf].buflisted = false
  vim.keymap.set("n", "q", function()
    vim.cmd("close")
  end, { buffer = buf, nowait = true })

  vim.api.nvim_buf_set_name(buf, title)
  vim.cmd("botright split | buffer " .. buf)

  local env = H.get_cmd_env(cmd[1])

  if env then
    local env_copy = vim.deepcopy(env)
    table.insert(env_copy, 1, "env")

    cmd = vim.list_extend(env_copy, cmd)
  else
    cmd = { unpack(cmd) }
  end

  vim.fn.jobstart(cmd, {
    cwd = S.cwd,
    term = true,
    on_exit = function(_, code)
      U.refresh_ui()

      if code == 0 then
        C.track_cmd({
          id = command_id,
          status = "success",
        })
        return
      end

      vim.schedule(function()
        -- 130 = Interrupted (Ctrl+C)
        if code == 130 then
          C.track_cmd({
            id = command_id,
            status = "cancelled",
          })
          pcall(vim.api.nvim_buf_delete, buf, { force = true })
          return
        end

        local cmd_string = table.concat(cmd, " ")

        local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
        lines = H.trim_empty_lines(lines)

        local preview = (#lines <= 6) and table.concat(lines, "\n")
          or table.concat(vim.list_slice(lines, 1, 3), "\n")
            .. "\n...omitted...\n"
            .. table.concat(vim.list_slice(lines, #lines - 2, #lines), "\n")

        H.notify(string.format("`%s` exited %d\n%s", cmd_string, code, preview), "ERROR")

        C.track_cmd({
          id = command_id,
          status = "failed",
        })
        pcall(vim.api.nvim_buf_delete, buf, { force = true })
      end)
    end,
  })

  vim.cmd("startinsert")
end

function U.refresh_ui()
  vim.schedule(function()
    vim.cmd("redraw!")
    vim.cmd("checktime")
  end)
end

------------------------------------------------------------------
-- Core
------------------------------------------------------------------

---@class Cmd.RunResult
---@field code integer
---@field out string
---@field err string

---Run a CLI command.
---@param cmd string[]
---@param command_id integer
---@param on_done fun(code: integer, out: string, err: string, is_cancelled?: boolean)
---@param timeout? integer Timeout in milliseconds
---@return Cmd.RunResult? result Only if synchronous
function C.exec_cli(cmd, command_id, on_done, timeout)
  timeout = timeout or Cmd.config.timeout

  H.ensure_cwd()

  -- Create a coroutine
  local stdout, stderr = uv.new_pipe(false), uv.new_pipe(false)
  local out_chunks, err_chunks = {}, {}
  local done = false
  ---@type uv.uv_timer_t|nil
  local timer

  local function finish(code, out, err)
    if done then
      return
    end
    done = true

    -- stop & close the timer so it can never fire
    if timer and not timer:is_closing() then
      timer:stop()
      timer:close()
    end

    if stdout and not stdout:is_closing() then
      stdout:close()
    end
    if stderr and not stderr:is_closing() then
      stderr:close()
    end

    local is_cancelled = code == 130
    local final_out = out or ""
    local final_err = err or ""

    vim.schedule(function()
      on_done(code, final_out, final_err, is_cancelled)
    end)
  end

  local process = uv.spawn(cmd[1], {
    args = vim.list_slice(cmd, 2),
    cwd = S.cwd,
    stdio = { nil, stdout, stderr },
    env = nil,
    uid = nil,
    gid = nil,
    verbatim = nil,
    detached = nil,
    hide = nil,
  }, function(code, signal)
    S.command_history[command_id].job = nil

    if signal == 2 then
      code = 130
    end -- SIGINT
    if signal == 15 then
      code = 143
    end -- SIGTERM
    if signal == 9 then
      code = 137
    end -- SIGKILL

    finish(code, H.stream_tostring(out_chunks), H.stream_tostring(err_chunks))
  end)

  if not process then
    on_done(127, "", string.format("failed to spawn process: %s", cmd[1]))
    return
  end

  S.command_history[command_id].job = process

  if stdout then
    H.read_stream(stdout, out_chunks)
  end
  if stderr then
    H.read_stream(stderr, err_chunks)
  end

  -- Set up timeout
  if timeout and timeout > 0 then
    timer = uv.new_timer()
    if timer then
      timer:start(timeout, 0, function()
        if process and not process:is_closing() then
          process:kill("sigterm")
          vim.defer_fn(function()
            if process and not process:is_closing() then
              process:kill("sigkill")
            end
          end, 1000)
        end
        timer:close()
        finish(124, "", string.format("process killed after timeout: %s", cmd[1]))
      end)
    end
  end
end

---@param job uv.uv_process_t|nil
---@param command_id number
function C.cancel_with_fallback(job, command_id)
  if not job or job:is_closing() then
    return
  end

  job:kill("sigint")
  vim.defer_fn(function()
    if job and not job:is_closing() then
      job:kill("sigkill")
    end
  end, 1000) -- give 1 second to terminate cleanly

  C.track_cmd({
    id = command_id,
    status = "cancelled",
  })
end

---Cancel the currently running command.
---@param command_id number|nil
---@param all boolean
---@return nil
local function cancel_cmd(command_id, all)
  if all then
    local count = 0
    for id, entry in pairs(S.command_history) do
      if entry.job and not entry.job:is_closing() then
        C.cancel_with_fallback(entry.job, entry.id)
        S.command_history[id].job = nil
        count = count + 1
      end
    end
    H.notify(string.format("Cancelled %d running commands", count), "WARN")
    return
  end

  local id = command_id or #S.command_history
  local job = S.command_history[id].job

  if job and not job:is_closing() then
    C.cancel_with_fallback(job, id)
    S.command_history[id].job = nil
  else
    H.notify("No running command to cancel", "WARN")
  end
end

---Get the cached shell completion for the given executable.
---@param executable? string
---@param lead_args string
---@param cmd_line string
---@param cursor_pos integer
function C.cached_shell_complete(executable, lead_args, cmd_line, cursor_pos)
  if Cmd.config.completion.enabled == false then
    return {}
  end

  H.ensure_cwd()

  --- this should be the root `Cmd` call rather than user defined commands
  --- we can then set the right executable and reconstruct the cmd_line to let it work normally
  if not executable then
    local cmd_line_table = vim.split(cmd_line, " ")
    table.remove(cmd_line_table, 1)

    executable = cmd_line_table[1]

    cmd_line = table.concat(cmd_line_table, " ")
  end

  local shell = Cmd.config.completion.shell or vim.env.SHELL or "/bin/bash"
  local script_path = H.write_temp_script(shell)
  if not script_path then
    H.notify("Failed to create temp script", "ERROR")
    return {}
  end

  -- Build the exact line the shell would see
  local full_line = cmd_line:sub(1, cursor_pos)

  local full_line_table = vim.split(full_line, " ")
  full_line_table[1] = executable
  full_line = table.concat(full_line_table, " ")

  local result = vim
    .system({ shell, script_path, full_line }, {
      text = true,
      cwd = S.cwd,
    })
    :wait()

  if result.code ~= 0 then
    H.notify("Shell completion failed with exit code: " .. result.code, "WARN")
    return {}
  end

  local lines = vim.split(result.stdout, "\n")

  local completions = H.sanitize_file_output(lines)

  return completions
end

---Run `cmd` command in terminal (interactive) or buffer (info).
---@param args string[]
---@param bang boolean
function C.run_cmd(args, bang)
  local executable = args[1]
  if vim.fn.executable(executable) == 0 then
    H.notify(executable .. " is not executable", "WARN")
    return
  end

  local command_id = #S.command_history + 1

  if bang then
    U.show_terminal(args, "cmd://" .. table.concat(args, " "), command_id)
  else
    C.track_cmd({
      id = command_id,
      cmd = args,
      type = "normal",
      status = "running",
    })

    local user_defined_notifier_id = nil

    if Cmd.config.async_notifier.adapter and type(Cmd.config.async_notifier.adapter) == "table" then
      user_defined_notifier_id = U.spinner_driver(Cmd.config.async_notifier.adapter).pre_exec({
        command_id = command_id,
        args_raw = args,
        args = table.concat(args, " "),
        get_spinner_state = H.get_spinner_state,
        set_spinner_state = H.set_spinner_state,
        spinner_chars = Cmd.config.async_notifier.spinner_chars,
      })
    else
      local msg = string.format("? [#%s] running `%s`", command_id, table.concat(args, " "))
      H.notify(msg, "INFO")
    end

    C.exec_cli(args, command_id, function(code, out, err, is_cancelled)
      ---@type Cmd.CommandStatus
      local status

      if is_cancelled then
        status = "cancelled"
      else
        status = code == 0 and "success" or "failed"

        local text = table.concat(H.trim_empty_lines({ err, out }), "\n")

        local lines = vim.split(text, "\n")
        lines = H.trim_empty_lines(lines)

        for i, line in ipairs(lines) do
          --- Strip ANSI escape codes
          lines[i] = line:gsub("\27%[[0-9;]*m", "")
        end

        if #lines > 0 then
          U.show_buffer(lines, "cmd://" .. table.concat(args, " ") .. "-" .. command_id)
        else
          H.notify("Completed but no output lines", "INFO")
        end

        if status == "success" then
          U.refresh_ui()
        end
      end

      if Cmd.config.async_notifier.adapter and type(Cmd.config.async_notifier.adapter) == "table" then
        U.spinner_driver(Cmd.config.async_notifier.adapter).post_exec({
          command_id = command_id,
          args_raw = args,
          args = table.concat(args, " "),
          get_spinner_state = H.get_spinner_state,
          set_spinner_state = H.set_spinner_state,
          status = status,
          user_defined_notifier_id = user_defined_notifier_id,
        })
      else
        local icon = icon_map[status] or " "
        local level = level_map[status] or vim.log.levels.ERROR

        local msg = string.format("%s [#%s] %s `%s`", icon, command_id, status, table.concat(args, " "))
        H.notify(msg, level)
      end

      C.track_cmd({
        id = command_id,
        status = status,
      })
    end)
  end
end

---@param opts Cmd.CommandHistory
function C.track_cmd(opts)
  opts = vim.tbl_deep_extend("force", S.command_history[opts.id] or {}, opts)

  opts.timestamp = os.time()

  S.command_history[opts.id] = opts
end

------------------------------------------------------------------
-- Public Interface
------------------------------------------------------------------

---@type Cmd.Config
Cmd.config = {}

---@class Cmd.Config.Completion
---@field enabled? boolean Whether to enable completion. Default: false
---@field shell? string Shell to use for the completion. Default: vim.env.SHELL
---@field prompt_pattern_to_remove? string Regex pattern to remove from the output, e.g. "^"

---@class Cmd.Config.AsyncNotifier.PreExec
---@field command_id integer
---@field args_raw string[]
---@field args string
---@field set_spinner_state fun(command_id: integer, opts: Cmd.Spinner|nil)
---@field get_spinner_state fun(command_id: integer): Cmd.Spinner|nil
---@field spinner_chars string[]
---@field current_spinner_char? string

---@class Cmd.Config.AsyncNotifier.PostExec
---@field command_id integer
---@field args_raw string[]
---@field args string
---@field set_spinner_state fun(command_id: integer, opts: Cmd.Spinner|nil)
---@field get_spinner_state fun(command_id: integer): Cmd.Spinner|nil
---@field status Cmd.CommandStatus
---@field user_defined_notifier_id? string|integer|number|nil

---@class Cmd.Config.AsyncNotifier
---@field spinner_chars? string[] Characters to use for the spinner. Default: { "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏
---@field adapter? Cmd.Config.AsyncNotifier.SpinnerAdapter

---@class Cmd.Config.AsyncNotifier.SpinnerAdapter
---@field start fun(msg: string, data: Cmd.Config.AsyncNotifier.PreExec): string|integer|nil
---@field update fun(notify_id: string|integer|number|nil, msg: string, data: Cmd.Config.AsyncNotifier.PreExec)
---@field finish fun(notify_id: string, msg: string, level: Cmd.LogLevel, data: Cmd.Config.AsyncNotifier.PostExec)

---@class Cmd.Config
---@field force_terminal? table<string, string[]> Detect any of these command to force terminal
---@field create_usercmd? table<string, string> Create user commands for these executables if it does'nt exists
---@field env? table<string, string[]> Environment variables to set for the command
---@field timeout? integer Job timeout in ms. Default: 30000
---@field completion? Cmd.Config.Completion Completion configuration
---@field async_notifier? Cmd.Config.AsyncNotifier Async notifier configuration
Cmd.defaults = {
  force_terminal = {},
  create_usercmd = {},
  env = {},
  timeout = 30000,
  completion = {
    enabled = false,
    shell = vim.env.SHELL or "/bin/sh",
  },
  async_notifier = {
    spinner_chars = { "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" },
    adapter = nil,
  },
}

local function create_usercmd_if_not_exists()
  local existing_cmds = vim.api.nvim_get_commands({})
  for executable, cmd_name in pairs(Cmd.config.create_usercmd) do
    if vim.fn.executable(executable) == 1 and not existing_cmds[cmd_name] then
      vim.api.nvim_create_user_command(cmd_name, function(opts)
        local fargs = vim.deepcopy(opts.fargs)

        -- to support expanding the args like %
        for i, arg in ipairs(fargs) do
          fargs[i] = vim.fn.expand(arg)
        end

        local args = { executable, unpack(fargs) }
        local bang = opts.bang

        local force_terminal_executable = Cmd.config.force_terminal[executable] or {}

        if not vim.tbl_isempty(force_terminal_executable) then
          for _, value in ipairs(force_terminal_executable) do
            local args_string = table.concat(args, " ")
            local matched = string.find(args_string, value, 1, true) ~= nil

            if matched == true then
              bang = true
              break
            end
          end
        end

        C.run_cmd(args, bang)
      end, {
        nargs = "*",
        bang = true,
        complete = function(...)
          return C.cached_shell_complete(executable, ...)
        end,
        desc = "Auto-generated command for " .. executable,
      })
    else
      H.notify(("%s is not executable or already exists"):format(executable), "WARN")
    end
  end
end

local function setup_usercmds()
  vim.api.nvim_create_user_command("Cmd", function(opts)
    local bang = opts.bang or false
    local args = vim.deepcopy(opts.fargs)

    -- to support expanding the args like %
    for i, arg in ipairs(args) do
      args[i] = vim.fn.expand(arg)
    end

    if #args < 1 then
      H.notify("No arguments provided", "WARN")
      return
    end

    local executable = args[1]

    if vim.fn.executable(executable) == 0 then
      H.notify(("%s is not executable"):format(executable), "WARN")
      return
    end

    local force_terminal_executable = Cmd.config.force_terminal[executable] or {}

    if not vim.tbl_isempty(force_terminal_executable) then
      for _, value in pairs(force_terminal_executable) do
        local args_string = table.concat(args, " ")
        local matched = string.find(args_string, value, 1, true) ~= nil

        if matched == true then
          bang = true
          break
        end
      end
    end

    C.run_cmd(args, bang)
  end, {
    nargs = "*",
    bang = true,
    complete = function(...)
      return C.cached_shell_complete(nil, ...)
    end,
    desc = "Run CLI command (add ! to run in terminal, add !! to rerun last command in terminal)",
  })

  vim.api.nvim_create_user_command("CmdRerun", function(opts)
    local bang = opts.bang or false
    local id = tonumber(opts.args) or #S.command_history
    local command_entry = S.command_history[id]

    local args = command_entry.cmd

    if not args then
      H.notify("No args to rerun", "WARN")
      return
    end

    local executable = args[1]

    local force_terminal_executable = Cmd.config.force_terminal[executable] or {}

    if not vim.tbl_isempty(force_terminal_executable) then
      for _, value in pairs(force_terminal_executable) do
        local args_string = table.concat(args, " ")
        local matched = string.find(args_string, value, 1, true) ~= nil

        if matched == true then
          bang = true
          break
        end
      end
    end

    C.run_cmd(args, bang)
  end, {
    bang = true,
    nargs = "?",
    desc = "Rerun the last command",
  })

  vim.api.nvim_create_user_command("CmdCancel", function(opts)
    local id = tonumber(opts.args)
    cancel_cmd(id, opts.bang)
  end, {
    bang = true,
    nargs = "?",
    desc = "Cancel the currently running Cmd (add ! to cancel all)",
  })

  vim.api.nvim_create_user_command("CmdHistory", function()
    local history = S.command_history

    if #history == 0 then
      H.notify("No command history", "INFO")
      return
    end

    ---@type table<integer, { text: string|osdate, hl_group: string }>[]
    local segments = {}

    local separator = {
      text = " ",
    }

    for i = #history, 1, -1 do
      local entry = history[i]
      local status_icon = icon_map[entry.status] or "?"

      local cmd_str = table.concat(entry.cmd, " ")
      local timetamp = entry.timestamp

      local pretty_time = os.date("%Y-%m-%d %H:%M:%S", timetamp)

      segments[i] = {
        {
          text = string.format("#%d", entry.id),
          hl_group = "CmdHistoryIdentifier",
        },
        separator,
        {
          text = pretty_time,
          hl_group = "CmdHistoryTime",
        },
        separator,
        {
          text = status_icon,
          hl_group = hl_groups[entry.status],
        },
        separator,
        {
          text = string.format("[%s]", entry.type:sub(1, 1):upper()),
          hl_group = hl_groups[entry.status],
        },
        separator,
        {
          text = cmd_str,
          hl_group = hl_groups[entry.status],
        },
      }
    end

    local lines = {}

    for i = 1, #segments do
      local flattened = {}
      local segment = segments[i]
      for j = 1, #segment do
        local item = segment[j]
        table.insert(flattened, item.text)
      end
      lines[i] = table.concat(flattened, "")
    end

    U.show_buffer(lines, "cmd://history", function(buf)
      local ns = vim.api.nvim_create_namespace("cmd_history")
      vim.api.nvim_buf_clear_namespace(buf, ns, 0, -1)

      for i = 1, #segments do
        local segment = segments[i]
        local col = 0
        for j = 1, #segment do
          local item = segment[j]
          if item.hl_group then
            vim.api.nvim_buf_set_extmark(buf, ns, i - 1, col, {
              end_col = col + #item.text,
              hl_group = item.hl_group,
            })
          end
          col = col + #item.text
        end
      end
    end)
  end, {
    desc = "History",
  })
end

local function setup_autocmds()
  vim.api.nvim_create_autocmd("VimLeavePre", {
    callback = function()
      -- stop all timers
      for _, st in pairs(S.spinner_state) do
        if st.timer and not st.timer:is_closing() then
          st.timer:stop()
          st.timer:close()
        end
      end

      -- delete all temp scripts
      for _, path in pairs(S.temp_script_cache) do
        H.safe_delete(path)
      end
    end,
  })
end

---Setup the default highlight groups.
local function setup_hls()
  local hi = function(name, opts)
    opts.default = true
    vim.api.nvim_set_hl(0, name, opts)
  end

  hi("CmdHistoryIdentifier", { link = "Identifier" })
  hi("CmdHistoryTime", { link = "Comment" })
  hi("CmdSuccess", { link = "MoreMsg" })
  hi("CmdFailed", { link = "ErrorMsg" })
  hi("CmdCancelled", { link = "WarningMsg" })
end

---@param adapter? Cmd.Config.AsyncNotifier.SpinnerAdapter
local function validate_adapter(adapter)
  if adapter == nil then
    return
  end

  if type(adapter) ~= "table" then
    error("`opts.async_notifier.adapter` must be a table")
  end

  if adapter.start == nil or type(adapter.start) ~= "function" then
    error("`opts.async_notifier.adapter.start` must be a function")
  end

  if adapter.update == nil or type(adapter.update) ~= "function" then
    error("`opts.async_notifier.adapter.update` must be a function")
  end

  if adapter.finish == nil or type(adapter.finish) ~= "function" then
    error("`opts.async_notifier.adapter.finish` must be a function")
  end
end

---Setup the `:Cmd` command.
---@param user_config? Cmd.Config
function Cmd.setup(user_config)
  Cmd.config = vim.tbl_deep_extend("force", Cmd.defaults, user_config or {})

  validate_adapter(Cmd.config.async_notifier.adapter)

  if Cmd.config.create_usercmd and not vim.tbl_isempty(Cmd.config.create_usercmd) then
    create_usercmd_if_not_exists()
  end

  setup_autocmds()
  setup_usercmds()
  setup_hls()
end

---@class Cmd.builtins
---@field spinner_driver fun(adapter: Cmd.Config.AsyncNotifier.SpinnerAdapter): Cmd.SpinnerDriver
---@field spinner_adapters table<"snacks"|"mini"|"fidget", Cmd.Config.AsyncNotifier.SpinnerAdapter>

---@type Cmd.builtins
Cmd.builtins = {
  spinner_driver = U.spinner_driver,
  spinner_adapters = U.spinner_adapters,
}

return Cmd
